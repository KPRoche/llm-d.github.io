"use strict";(self.webpackChunkdocusaurus_test=self.webpackChunkdocusaurus_test||[]).push([[6825],{3224:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"architecture/Components/kv-cache","title":"KV-Cache Manager","description":"Introduction","source":"@site/docs/architecture/Components/06_kv-cache.md","sourceDirName":"architecture/Components","slug":"/architecture/Components/kv-cache","permalink":"/llm-d.github.io/docs/architecture/Components/kv-cache","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidecar_position":6,"sidecar_label":"KV-Cache Manager"},"sidebar":"structureSidebar","previous":{"title":"Routing Sidecar","permalink":"/llm-d.github.io/docs/architecture/Components/routing-sidecar"}}');var s=r(4848),t=r(8453);const o={sidecar_position:6,sidecar_label:"KV-Cache Manager"},a="KV-Cache Manager",c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Goals",id:"goals",level:2},{value:"Vision",id:"vision",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Detailed System Flow",id:"detailed-system-flow",level:3},{value:"Explanation",id:"explanation",level:3},{value:"Maintenance of Redis for KVBlock -&gt; Pods Mapping",id:"maintenance-of-redis-for-kvblock---pods-mapping",level:3},{value:"Examples",id:"examples",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"kv-cache-manager",children:"KV-Cache Manager"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"LLM inference can be computationally expensive due to the sequential nature of token generation.\r\nKV-caching plays a critical role in optimizing this process. By storing previously computed key and value attention vectors,\r\nKV-cache reuse avoids redundant computations during inference, significantly reducing latency and resource consumption.\r\nThis is particularly beneficial for long context multi-turn conversations or Agentic (&RAG) applications where\r\npreviously computed information can be leveraged effectively.\r\nEfficient KV-cache management and routing are essential for scaling LLM inference and delivering a responsive user experience."}),"\n",(0,s.jsx)(n.p,{children:"llmd-kv-cache-manager is a pluggable KV-cache Manager for KV-cache Aware Routing in LLM serving platforms."}),"\n",(0,s.jsx)(n.p,{children:"This initial work will expand in capacity as development continues."}),"\n",(0,s.jsxs)(n.p,{children:["See the ",(0,s.jsx)(n.a,{href:"https://github.com/llm-d/llm-d-kv-cache-manager/blob/main/docs/README.md",children:"docs folder in the repository"})," for more information on goals, architecture and more."]}),"\n",(0,s.jsx)(n.h2,{id:"goals",children:"Goals"}),"\n",(0,s.jsx)(n.p,{children:"The KV-Cache-Manager is designed to connect high-level serving-stack goals with concrete system capabilities through a layered objective structure:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Improve user experience"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["By reducing Time-To-First-Token (TTFT)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Enabled through higher KVCache hit rates and reduced tensor transfers"}),"\n",(0,s.jsx)(n.li,{children:"Supported by smart routing and distributed cache availability"}),"\n",(0,s.jsx)(n.li,{children:"Optimized by proactive pre-placement of hot caches and session duplication/migration"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduce serving costs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["By improving compute utilization","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Minimize re-compute via KVCache reuse and locality-aware request handling"}),"\n",(0,s.jsx)(n.li,{children:"Leverage zero-copy cache transfers across nodes"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"vision",children:"Vision"}),"\n",(0,s.jsx)(n.p,{children:"This goal structure above is shaped by our vision for emerging use cases like RAG and agentic workflows,\r\nwhich involve heavy context-reuse across sessions and instances.\r\nShared documents, tool prompts, and workflow steps create overlapping token streams that benefit significantly from\r\ncross-instance KVCache coordination."}),"\n",(0,s.jsx)(n.p,{children:"To implement this vision, the KVCache-Manager incorporates proactive cache placement, session duplication,\r\nand cluster-level cache APIs - bridging gaps in current serving stacks where KVCache management and utilization is\r\nnot yet treated as a first-class concern."}),"\n",(0,s.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The code defines a ",(0,s.jsx)(n.a,{href:"https://github.com/llm-d/llm-d-kv-cache-manager/tree/main/pkg/kv-cache/indexer.go",children:"kvcache.Indexer"})," module that efficiently maintains a global view of KV-cache states and localities.\r\nIn the current state of vLLM, the only available information on KV-cache availability is that of the offloaded tensors to KV-cache Engines via the Connector API."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"kvcache.Indexer"})," module is a pluggable Go package designed for use by orchestrators to enable KV-cache-aware scheduling decisions."]}),"\n",(0,s.jsx)(n.mermaid,{value:'graph \r\n  subgraph Cluster\r\n    Router\r\n    subgraph KVCacheManager[KV-cache Manager]\r\n      kvcache.Indexer[KV-cache Indexer]\r\n      PrefixStore[LRU Prefix Store]\r\n      KVBlockToPodIndex[KVBlock to Pod availability Index]\r\n    end\r\n    subgraph vLLMNode[vLLM Node]\r\n      vLLMCore[vLLM Core]\r\n      KVCacheEngine["KV-cache Engine (LMCache)"]\r\n    end\r\n    Redis\r\n  end\r\n\r\n  Router --\x3e|"Score(prompt, ModelName, relevantPods)"| kvcache.Indexer\r\n  kvcache.Indexer --\x3e|"{Pod to Scores map}"| Router\r\n  Router --\x3e|Route| vLLMNode\r\n  \r\n  kvcache.Indexer --\x3e|"FindLongestTokenizedPrefix(prompt, ModelName) -> tokens"| PrefixStore\r\n  PrefixStore --\x3e|"DigestPromptAsync"| PrefixStore\r\n  kvcache.Indexer --\x3e|"GetPodsForKeys(tokens) -> {KVBlock keys to Pods} availability map"| KVBlockToPodIndex\r\n  KVBlockToPodIndex --\x3e|"Redis MGet(blockKeys) -> {KVBlock keys to Pods}"| Redis\r\n\r\n  vLLMCore --\x3e|Connector API| KVCacheEngine\r\n  KVCacheEngine --\x3e|"UpdateIndex(KVBlock keys, nodeIP)"| Redis'}),"\n",(0,s.jsx)(n.p,{children:"This overview greatly simplifies the actual architecture and combines steps across several submodules."}),"\n",(0,s.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsxs)(n.p,{children:["For even more a detailed architecture, refer to the ",(0,s.jsx)(n.a,{href:"https://github.com/llm-d/llm-d-kv-cache-manager/tree/main/docs/architecture.md",children:"architecture"})," document."]}),"\n",(0,s.jsx)(n.p,{children:"The architecture is designed to efficiently maintain a global view of KV-cache states and localities, enabling KV-cache-aware scheduling decisions."}),"\n",(0,s.jsx)(n.h3,{id:"detailed-system-flow",children:"Detailed System Flow"}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\r\n    participant U as User  \r\n    participant KVI as kvcache.Indexer\r\n    box\r\n        participant KVBS as KVBlockScorer\r\n        participant TPR as TokenProcessor\r\n        participant KVBI as KVBlockIndexer\r\n        participant Redis as Redis\r\n    end\r\n    box\r\n        participant PS as PrefixStore\r\n        participant LRUS as LRUStore\r\n        participant TS as TrieStore\r\n    end\r\n    box\r\n        participant TPO as TokenizersPool\r\n        participant W as Worker\r\n        participant CHT as HuggingFaceTokenizer\r\n        participant CH as TokenizersCache\r\n    end\r\n\r\n# kvcache.Indexer\r\nU->>KVI: 1. Score(prompt, ModelName, relevantPods)\r\n\r\n# get available tokens of longest prefix\r\nKVI->>PS: 2. FindLongestTokenizedPrefix(prompt, ModelName)\r\n    alt LRU\r\n        PS->>LRUS: 2.1 BuildLongestPrefix(prompt, ModelName)\r\n    else Trie\r\n        PS->>TS: 2.1 BuildLongestPrefix(prompt, ModelName)\r\n    end\r\nPS->>KVI: 2.2 Tokens of longest prefix\r\n\r\n# get block keys  \r\nKVI->>TPR: 3 GetBlockKeys(tokens, ModelName)\r\n    TPR->>KVI: 3.1 BlockKeys\r\n\r\n# query kvblock indexer for pods\r\nKVI->>KVBI: 4. GetPodsForKeys(blockKeys, relevantPods)\r\nKVBI->>Redis: 4.1 MGet(blockKeys)\r\nRedis->>KVBI: 4.2 key -> Pods mapping (KV-cache availability)\r\nKVBI->>KVBI: 4.3 FilterPods(relevantPods)\r\n\r\n# score pods\r\nKVI->>KVBS: 5. ScorePods(key->Pods) based on strategy\r\n\r\n# results\r\nKVI->>U: 6. Pod -> Score mapping\r\n\r\n# add to tokenizers pool\r\nKVI->>TPO: 2. AddTask(prompt, ModelName) // Registers task only\r\nNote over TPO: Task added to queue\r\nW--\x3e>TPO: 2.1 Get(Task) // Async worker fetches task\r\nW->>CHT: 2.3 Tokenize(prompt, ModelName)\r\nCHT->>CH: 2.4 GetCachedTokenizerForModel()\r\nCHT->>W: 2.5 Tokens\r\nW->>PS: 2.6 AddTokens(prompt, ModelName, tokens)\r\nalt LRU\r\n    PS->>LRUS: 2.7 AddTokens(prompt, ModelName, tokens)\r\nelse Trie\r\n    PS->>TS: 2.7 AddTokens(prompt, ModelName, tokens)\r\nend"}),"\n",(0,s.jsx)(n.h3,{id:"explanation",children:"Explanation"}),"\n",(0,s.jsx)(n.p,{children:"The main blocking sequence of steps that happens when a user (e.g., router) sends a request to the kvcache.Indexer is as follows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User"})," sends a request to the ",(0,s.jsx)(n.strong,{children:"kvcache.Indexer"})," with a prompt, model name, and relevant pods."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"kvcache.Indexer"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Finds the longest tokenized prefix for the prompt and model name using the ",(0,s.jsx)(n.strong,{children:"PrefixStore"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Depending on the store type (LRU or Trie), it gets the tokenization of the longest cached prefix"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Adds a tokenization task to the ",(0,s.jsx)(n.strong,{children:"TokenizersPool"}),", which is handled asynchronously by a worker. This bit is explained later."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"kvcache.Indexer"})," queries the ",(0,s.jsx)(n.strong,{children:"TokenProcessor"})," to get block keys for the tokens of the longest prefix."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TokenProcessor"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Chunks the tokens and generate keys for the token blocks. The chunking and key calculating has to be aligned with\r\nthe source that feeds the key -> pods backend (Redis)."}),"\n",(0,s.jsxs)(n.li,{children:["Returns the block keys to the ",(0,s.jsx)(n.strong,{children:"kvcache.Indexer"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"kvcache.Indexer"})," queries the ",(0,s.jsx)(n.strong,{children:"KVBlockIndexer"})," for pods that have the block keys.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"KVBlockIndexer"})," queries the ",(0,s.jsx)(n.strong,{children:"Redis"})," backend for the mappings with MGet."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"Redis"})," backend efficiently returns the key -> pods mapping."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"kvcache.Indexer"})," uses the configured ",(0,s.jsx)(n.strong,{children:"KVBlockScorer"})," to score the pods based block hits:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"LongestPrefixMatch: scores by the longest consecutive (ordered) block hits in a single pod."}),"\n",(0,s.jsx)(n.li,{children:"HighestBlockHit: scores by the index of the highest block hit in a single pod."}),"\n",(0,s.jsx)(n.li,{children:"CoverageBasedMatching: scores by the total number of block hits in a single pod."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Asynchronous tokenization flow:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["A worker fetches the task from the ",(0,s.jsx)(n.strong,{children:"TokenizersPool"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The worker tokenizes the prompt using the ",(0,s.jsx)(n.strong,{children:"HuggingFaceTokenizer"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"HuggingFaceTokenizer"})," retrieves the cached in-memory tokenizer for the model.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If the tokenizer is not cached, it gets created and cached."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"HuggingFaceTokenizer"})," returns the tokens to the worker."]}),"\n",(0,s.jsxs)(n.li,{children:["The worker adds the tokens to the ",(0,s.jsx)(n.strong,{children:"PrefixStore"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Depending on the store type (LRU or Trie), it adds the tokens to the appropriate store:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"LRUStore: an LRU HashTable of prompt-chunks to tokens"}),"\n",(0,s.jsx)(n.li,{children:"TrieStore: a Trie of characters to tokens"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Due to the nature of how tokenizers operate, the tokenization of a prefix of a prompt is a prefix of the tokenization of the full prompt.\r\nOne challenge in tokenization is that different chunks of a prompt map to different tokens.\r\nTherefore, when we chunk a prompt, we use the [_, end] index associated with the tokens to contain token in a chunk.\r\nThe implication of this design is that the tokens contained in a chunk are only correct if all previous chunks are also considered,\r\nsince one token may be associated with the edge-characters of two consecutive chunks."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"maintenance-of-redis-for-kvblock---pods-mapping",children:"Maintenance of Redis for KVBlock -> Pods Mapping"}),"\n",(0,s.jsx)(n.p,{children:"Currently, indexing information is updated from vLLM for the offloaded tokens using the Connector API, specifically leveraging the LMCache connector."}),"\n",(0,s.jsxs)(n.p,{children:["Future enhancements will enable the ",(0,s.jsx)(n.code,{children:"llm-d-kv-cache-manager"})," component to process KV-cache events across all memory layers of vLLM, ensuring an accurate holistic view of KV-cache localities throughout the system."]}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/llm-d/llm-d-kv-cache-manager/tree/main/examples/kv-cache-index/",children:"KV-cache Indexer"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A reference implementation of using the ",(0,s.jsx)(n.code,{children:"kvcache.Indexer"})," module."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/llm-d/llm-d-kv-cache-manager/tree/main/examples/kv-cache-aware-scorer/",children:"KV-cache Aware Scorer"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A reference implementation of integrating the ",(0,s.jsx)(n.code,{children:"kvcache.Indexer"})," module in\r\n",(0,s.jsx)(n.a,{href:"https://github.com/llm-d/llm-d-inference-scheduler",children:"llm-d-inference-scheduler"})," in a KV-cache aware scorer."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var i=r(6540);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);